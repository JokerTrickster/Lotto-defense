# Task 009: Unit Upgrade System

## Metadata
```yaml
---
epic: lotto-defense
task_id: "009"
title: "Unit Upgrade System"
status: todo
priority: high
estimated_hours: 8
depends_on: ["003", "004"]
parallel: true
created: 2025-10-28T02:12:15Z
updated: 2025-10-28T02:12:15Z
assignee: unity-game-developer
conflicts_with: ["008"]
---
```

## Overview
Implement unit upgrade system allowing players to spend gold to incrementally improve individual unit stats. Provides alternative progression path to synthesis system.

## Requirements

### Functional Requirements
- **Upgrade UI Panel**: Display current stats, upgrade cost, preview of new stats
- **Cost Formula**: 10 * level^1.5 gold per upgrade, capped at level 10
- **Stat Modification**: Increase unit attack stat by 10% per level (multiplicative)
- **Gold Transaction**: Check player gold, deduct cost on upgrade
- **Level Tracking**: Persist unit upgrade level across sessions

### Technical Requirements
- **Namespace**: LottoDefense.Units (UpgradeManager), LottoDefense.UI (UpgradePanel)
- **Dependencies**: UnitManager (Task 003), PlayerStats (gold system)
- **Performance**: Upgrade calculation < 1ms, UI updates < 16ms
- **Conflicts**: Modifies UnitManager alongside Task 008 (requires coordination)

## Implementation Plan

### Files to Create
```
Assets/Scripts/Units/UpgradeManager.cs
Assets/Scripts/UI/UpgradePanel.cs
```

### Core Components

#### 1. UpgradeManager.cs
```csharp
namespace LottoDefense.Units
{
    [System.Serializable]
    public struct UpgradeStats
    {
        public int level;
        public int upgradeCost;
        public float attackMultiplier;
        public float nextAttackMultiplier;
    }

    public class UpgradeManager : MonoBehaviour
    {
        [Header("Configuration")]
        [SerializeField] private int maxUpgradeLevel = 10;
        [SerializeField] private float baseCost = 10f;
        [SerializeField] private float costExponent = 1.5f;
        [SerializeField] private float attackIncreasePerLevel = 0.1f; // 10% per level

        // References
        private UnitManager unitManager;
        private PlayerStats playerStats;

        // Events
        public event Action<Unit, int> OnUnitUpgraded;
        public event Action<string> OnUpgradeFailed;

        // Unit upgrade state (persisted)
        private Dictionary<string, int> unitUpgradeLevels = new Dictionary<string, int>();

        public bool CanUpgradeUnit(Unit unit);
        public int GetUpgradeCost(int currentLevel);
        public UpgradeStats GetUpgradeStats(Unit unit);
        public bool TryUpgradeUnit(Unit unit);
        public int GetUnitLevel(Unit unit);
        private void ApplyUpgrade(Unit unit, int newLevel);
        private float CalculateAttackMultiplier(int level);

        // Save/Load
        public void SaveUpgradeState();
        public void LoadUpgradeState();
    }
}
```

#### 2. UpgradePanel.cs
```csharp
namespace LottoDefense.UI
{
    public class UpgradePanel : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private GameObject panelRoot;
        [SerializeField] private Image unitIcon;
        [SerializeField] private TextMeshProUGUI unitNameText;
        [SerializeField] private TextMeshProUGUI currentLevelText;

        [Header("Stats Display")]
        [SerializeField] private TextMeshProUGUI currentAttackText;
        [SerializeField] private TextMeshProUGUI nextAttackText;
        [SerializeField] private GameObject maxLevelIndicator;

        [Header("Upgrade Button")]
        [SerializeField] private Button upgradeButton;
        [SerializeField] private TextMeshProUGUI upgradeCostText;
        [SerializeField] private Image goldIcon;

        [Header("Visual Feedback")]
        [SerializeField] private Color affordableColor = Color.green;
        [SerializeField] private Color unaffordableColor = Color.red;
        [SerializeField] private ParticleSystem upgradeSuccessParticles;
        [SerializeField] private AudioClip upgradeSuccessSound;

        // State
        private Unit selectedUnit;
        private UpgradeManager upgradeManager;
        private PlayerStats playerStats;

        public void Show(Unit unit);
        public void Hide();
        public void OnUpgradeButtonClicked();
        private void UpdateDisplay();
        private void UpdateUpgradeButton();
        private void ShowUpgradeSuccess();
        private void ShowUpgradeError(string message);
    }
}
```

### Cost Formula Implementation

```csharp
// Cost Curve Examples:
// Level 1 → 2: 10 * 1^1.5 = 10 gold
// Level 2 → 3: 10 * 2^1.5 = 28 gold
// Level 3 → 4: 10 * 3^1.5 = 52 gold
// Level 5 → 6: 10 * 5^1.5 = 112 gold
// Level 9 → 10: 10 * 9^1.5 = 270 gold
// Total cost 1→10: ~1,000 gold

public int GetUpgradeCost(int currentLevel)
{
    if (currentLevel >= maxUpgradeLevel)
        return int.MaxValue; // Cannot upgrade further

    return Mathf.RoundToInt(baseCost * Mathf.Pow(currentLevel, costExponent));
}
```

### Attack Multiplier Formula

```csharp
// Attack Multiplier Examples:
// Level 1: 1.0x (base)
// Level 2: 1.1x (+10%)
// Level 5: 1.4x (+40%)
// Level 10: 1.9x (+90%)

private float CalculateAttackMultiplier(int level)
{
    return 1.0f + (attackIncreasePerLevel * (level - 1));
}
```

### Implementation Steps

1. **Create UpgradeManager**
   - Implement cost calculation formula
   - Implement attack multiplier calculation
   - Unit upgrade level tracking
   - Gold transaction validation
   - Save/load upgrade state

2. **Implement Unit Stats Modification**
   - Add upgrade level to Unit class
   - Apply attack multiplier to base attack stat
   - Persist upgrade level in unit data

3. **Create UpgradePanel UI**
   - Current stats display (level, attack)
   - Next level preview (new attack, cost)
   - Upgrade button with affordability check
   - Max level indicator (level 10)

4. **Visual Feedback**
   - Affordable: Green button, gold icon
   - Unaffordable: Red button, grayed out
   - Success: Particles, sound, stat number flash
   - Error: Shake animation, error message

5. **Integration with Unit Selection**
   - Click unit → Show upgrade panel
   - Display unit-specific stats
   - Update panel on upgrade success

6. **Testing**
   - Validate cost formula progression
   - Test gold deduction
   - Test max level cap
   - Test insufficient gold handling
   - Test save/load persistence

## Acceptance Criteria
- [ ] Upgrade panel displays current level, stats, and cost
- [ ] Cost formula: 10 * level^1.5, capped at level 10
- [ ] Attack increases by 10% per level (multiplicative)
- [ ] Gold cost validated and deducted on upgrade
- [ ] Max level (10) prevents further upgrades
- [ ] Upgrade button disabled when insufficient gold or max level
- [ ] Success animation plays on successful upgrade
- [ ] Upgrade state persists across sessions
- [ ] UI updates complete in < 16ms

## Testing Strategy

### Unit Tests
```csharp
[Test]
public void UpgradeManager_GetUpgradeCost_Level1_Returns10();
[Test]
public void UpgradeManager_GetUpgradeCost_Level5_Returns112();
[Test]
public void UpgradeManager_GetUpgradeCost_Level10_ReturnsMaxValue();
[Test]
public void UpgradeManager_CalculateAttackMultiplier_Level1_Returns1_0();
[Test]
public void UpgradeManager_CalculateAttackMultiplier_Level5_Returns1_4();
[Test]
public void UpgradeManager_CalculateAttackMultiplier_Level10_Returns1_9();
[Test]
public void UpgradeManager_TryUpgradeUnit_InsufficientGold_ReturnsFalse();
[Test]
public void UpgradeManager_TryUpgradeUnit_MaxLevel_ReturnsFalse();
[Test]
public void UpgradeManager_TryUpgradeUnit_ValidUpgrade_IncreasesLevel();
[Test]
public void UpgradeManager_SaveLoad_PreservesUpgradeState();
```

### Integration Tests
- Test unit selection → upgrade panel display
- Test upgrade success → gold deduction → stat update
- Test multiple upgrades in sequence
- Test max level reach → button disabled

### Manual Testing
- Verify cost scaling feels balanced
- Verify attack increase is noticeable
- Verify UI feedback is clear (affordable/unaffordable)
- Verify success animation is satisfying
- Test edge case: upgrade with exact gold amount

## Dependencies
- Task 003: UnitManager (modify for upgrade operations)
- Task 004: Unit selection system
- PlayerStats system (gold management)

## Notes
- **Conflict with Task 008**: Both tasks modify UnitManager - coordinate changes carefully
- **Recommendation**: Implement after Task 008 to avoid merge conflicts
- Consider visual indicator on units showing upgrade level (stars, glow)
- Future: Add HP/Defense upgrade options
- Future: Discount system for bulk upgrades
- Balance tuning: Adjust cost exponent (1.5) if progression too steep/shallow

## Conflicts
- **Task 008 (Unit Synthesis System)**: Both modify UnitManager
  - **Resolution**: Coordinate UnitManager changes, ensure methods don't conflict
  - **Implementation Order**: Implement after Task 008 completes
  - **Specific Conflicts**:
    - Both add state tracking to units (synthesis flags vs upgrade levels)
    - Both modify unit stats (synthesis replaces units, upgrade enhances them)
  - **Mitigation**: Use separate methods in UnitManager, clear separation of concerns

## Risk Assessment
- **Low Risk**: Straightforward math formulas, minimal complexity
- **Mitigation**: Thorough testing of cost/multiplier calculations
- **Balance Risk**: Cost curve may need tuning after playtesting
- **Mitigation**: Make cost parameters easily adjustable in inspector

## UI/UX Considerations
- **Upgrade Preview**: Show before/after stats clearly
- **Cost Affordability**: Color-code based on player gold
- **Max Level Celebration**: Special animation when reaching level 10
- **Undo Protection**: Confirmation dialog for expensive upgrades (optional)
- **Quick Upgrade**: Hold button to rapidly upgrade (if gold available)
