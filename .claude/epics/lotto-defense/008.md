# Task 008: Unit Synthesis System

## Metadata
```yaml
---
epic: lotto-defense
task_id: "008"
title: "Unit Synthesis System"
status: todo
priority: high
estimated_hours: 16
depends_on: ["003", "004"]
parallel: true
created: 2025-10-28T02:12:15Z
updated: 2025-10-28T02:12:15Z
assignee: unity-game-developer
conflicts_with: ["009"]
---
```

## Overview
Implement unit synthesis system allowing players to combine multiple units into stronger units through recipe-based transformations. Provides progression path for unit enhancement.

## Requirements

### Functional Requirements
- **Recipe System**: 5-10 SynthesisRecipe ScriptableObjects defining ingredient → result transformations
- **Synthesis UI**: Panel with drag/click interface to add units, validate combinations
- **Transformation Logic**: Remove ingredient units, spawn result unit at synthesis location
- **Visual Feedback**: Clear indicators for valid/invalid recipes, recipe discovery, success animations
- **Recipe Discovery**: Show available recipes, highlight discovered vs undiscovered

### Technical Requirements
- **Namespace**: LottoDefense.Units (SynthesisManager), LottoDefense.UI (SynthesisPanel)
- **Dependencies**: UnitManager (Task 003), Unit placement system (Task 004)
- **Performance**: Recipe validation < 16ms, smooth drag interactions
- **Conflicts**: Modifies UnitManager alongside Task 009 (requires coordination)

## Implementation Plan

### Files to Create
```
Assets/Scripts/Units/SynthesisManager.cs
Assets/Scripts/Units/SynthesisRecipe.cs
Assets/Scripts/UI/SynthesisPanel.cs
Assets/Data/Recipes/BasicArcher.asset
Assets/Data/Recipes/EliteWarrior.asset
Assets/Data/Recipes/MasterMage.asset
Assets/Data/Recipes/HolyKnight.asset
Assets/Data/Recipes/DragonSlayer.asset
Assets/Data/Recipes/CelestialGuardian.asset
Assets/Data/Recipes/InfernoWizard.asset
Assets/Data/Recipes/FrostArchon.asset
Assets/Data/Recipes/StormCaller.asset
Assets/Data/Recipes/VoidReaper.asset
```

### Core Components

#### 1. SynthesisRecipe.cs
```csharp
namespace LottoDefense.Units
{
    [System.Serializable]
    public struct RecipeIngredient
    {
        public UnitData unitData;
        public int quantity;
    }

    [CreateAssetMenu(fileName = "SynthesisRecipe", menuName = "LottoDefense/Synthesis Recipe")]
    public class SynthesisRecipe : ScriptableObject
    {
        [Header("Recipe Definition")]
        [SerializeField] private string recipeName;
        [SerializeField] private RecipeIngredient[] ingredients;
        [SerializeField] private UnitData resultUnit;

        [Header("Discovery")]
        [SerializeField] private bool startsDiscovered = false;
        [SerializeField] private Sprite recipeIcon;
        [SerializeField] [TextArea(2, 4)] private string recipeDescription;

        public string RecipeName => recipeName;
        public RecipeIngredient[] Ingredients => ingredients;
        public UnitData ResultUnit => resultUnit;
        public bool StartsDiscovered => startsDiscovered;
        public Sprite RecipeIcon => recipeIcon;
        public string Description => recipeDescription;

        public bool ValidateIngredients(List<Unit> selectedUnits);
        public int GetTotalIngredientCount();
    }
}
```

#### 2. SynthesisManager.cs
```csharp
namespace LottoDefense.Units
{
    public class SynthesisManager : MonoBehaviour
    {
        [Header("Configuration")]
        [SerializeField] private SynthesisRecipe[] allRecipes;
        [SerializeField] private Transform synthesisEffectPrefab;

        [Header("Discovery State")]
        private HashSet<string> discoveredRecipes = new HashSet<string>();

        // References
        private UnitManager unitManager;
        private SynthesisPanel synthesisPanel;

        // Events
        public event Action<SynthesisRecipe> OnRecipeDiscovered;
        public event Action<UnitData> OnSynthesisComplete;

        private void Awake()
        {
            LoadRecipes();
            InitializeDiscoveredRecipes();
        }

        public bool TrySynthesize(List<Unit> selectedUnits, SynthesisRecipe recipe);
        public List<SynthesisRecipe> GetValidRecipes(List<Unit> selectedUnits);
        public List<SynthesisRecipe> GetDiscoveredRecipes();
        public void DiscoverRecipe(SynthesisRecipe recipe);
        private void PerformSynthesis(List<Unit> ingredients, SynthesisRecipe recipe, Vector3 synthesisPosition);
        private void SpawnSynthesisEffect(Vector3 position);
        private void RemoveIngredientUnits(List<Unit> units);
        private Unit SpawnResultUnit(UnitData unitData, Vector3 position);

        // Save/Load
        public void SaveDiscoveryState();
        public void LoadDiscoveryState();
    }
}
```

#### 3. SynthesisPanel.cs
```csharp
namespace LottoDefense.UI
{
    public class SynthesisPanel : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private GameObject panelRoot;
        [SerializeField] private Transform recipeListContainer;
        [SerializeField] private RecipeSlot recipeSlotPrefab;
        [SerializeField] private Transform selectedUnitsContainer;
        [SerializeField] private SelectedUnitSlot selectedUnitSlotPrefab;
        [SerializeField] private Button synthesizeButton;
        [SerializeField] private TextMeshProUGUI statusText;

        [Header("Visual Feedback")]
        [SerializeField] private Color validRecipeColor = Color.green;
        [SerializeField] private Color invalidRecipeColor = Color.red;
        [SerializeField] private ParticleSystem successParticles;

        // State
        private List<Unit> selectedUnits = new List<Unit>();
        private SynthesisRecipe currentRecipe;
        private SynthesisManager synthesisManager;

        // Events
        public event Action<List<Unit>> OnUnitsSelected;

        public void Show();
        public void Hide();
        public void AddSelectedUnit(Unit unit);
        public void RemoveSelectedUnit(Unit unit);
        public void ClearSelection();
        public void TrySynthesis();
        private void UpdateRecipeList();
        private void UpdateSelectedUnitsDisplay();
        private void UpdateSynthesizeButton();
        private void ValidateCurrentSelection();
        private void ShowSuccessFeedback();
        private void ShowErrorFeedback(string message);
    }

    public class RecipeSlot : MonoBehaviour
    {
        [SerializeField] private Image recipeIcon;
        [SerializeField] private TextMeshProUGUI recipeNameText;
        [SerializeField] private GameObject discoveredIndicator;
        [SerializeField] private GameObject newIndicator;

        public void Initialize(SynthesisRecipe recipe, bool isDiscovered);
        public void SetHighlight(bool highlighted);
    }

    public class SelectedUnitSlot : MonoBehaviour
    {
        [SerializeField] private Image unitIcon;
        [SerializeField] private Button removeButton;

        public void Initialize(Unit unit, System.Action<Unit> onRemove);
    }
}
```

### Recipe Examples

#### BasicArcher Recipe
```
Ingredients: 3x Common Warrior
Result: Uncommon Archer (2x attack, +range)
Description: "Combine three warriors to train an archer with superior range"
```

#### EliteWarrior Recipe
```
Ingredients: 3x Common Warrior + 1x Common Mage
Result: Rare Elite Warrior (3x attack, 2x HP)
Description: "Warriors trained by mages become elite fighters"
```

#### MasterMage Recipe
```
Ingredients: 5x Common Mage
Result: Epic Master Mage (5x attack, AoE damage)
Description: "Five mages unite their knowledge to become a master"
```

#### HolyKnight Recipe
```
Ingredients: 2x Uncommon Archer + 1x Rare Elite Warrior
Result: Epic Holy Knight (4x attack, 3x HP, heals allies)
Description: "A blessed knight with divine powers"
```

#### DragonSlayer Recipe
```
Ingredients: 3x Epic Units (any combination)
Result: Legendary Dragon Slayer (10x attack, 5x HP, dragon-killer bonus)
Description: "The ultimate warrior forged from three epic heroes"
```

### Implementation Steps

1. **Create SynthesisRecipe ScriptableObject**
   - Define base structure with ingredients/result
   - Create 5-10 recipe assets with progression curve
   - Design recipe discovery system

2. **Implement SynthesisManager**
   - Recipe validation logic
   - Unit transformation (remove → spawn)
   - Discovery state management
   - Save/load system for discovered recipes

3. **Create SynthesisPanel UI**
   - Recipe list display (discovered/undiscovered)
   - Selected units display area
   - Drag/click unit selection
   - Visual validation feedback

4. **Unit Selection System**
   - Click units to add to synthesis queue
   - Remove units from queue
   - Multi-select support
   - Visual selection indicators on units

5. **Visual Feedback**
   - Valid recipe: Green highlight, enabled button
   - Invalid recipe: Red highlight, disabled button
   - Success animation: Particles, sound, camera shake
   - New recipe discovered notification

6. **Testing**
   - Validate all 5-10 recipes work correctly
   - Test edge cases (insufficient units, invalid combinations)
   - Test UI responsiveness and visual feedback
   - Test save/load of discovery state

## Acceptance Criteria
- [ ] 5-10 SynthesisRecipe assets created with balanced progression
- [ ] Players can select units via click/drag interface
- [ ] Recipe validation provides clear visual feedback (valid/invalid)
- [ ] Synthesis removes ingredient units and spawns result unit
- [ ] Discovered recipes persist across sessions
- [ ] Success animation plays on successful synthesis
- [ ] Recipe list shows discovered vs undiscovered recipes
- [ ] Synthesis validation completes in < 16ms

## Testing Strategy

### Unit Tests
```csharp
[Test]
public void SynthesisRecipe_ValidateIngredients_ValidCombination_ReturnsTrue();
[Test]
public void SynthesisRecipe_ValidateIngredients_InvalidCombination_ReturnsFalse();
[Test]
public void SynthesisManager_TrySynthesize_ValidRecipe_RemovesIngredientsAndSpawnsResult();
[Test]
public void SynthesisManager_TrySynthesize_InvalidRecipe_ReturnsFalse();
[Test]
public void SynthesisManager_GetValidRecipes_ReturnsOnlyMatchingRecipes();
[Test]
public void SynthesisManager_DiscoverRecipe_AddsToDiscoveredSet();
[Test]
public void SynthesisManager_SaveLoad_PreservesDiscoveryState();
```

### Integration Tests
- Test unit selection → validation → synthesis flow
- Test recipe discovery notification
- Test UI updates after synthesis
- Test multiple synthesis operations in sequence

### Manual Testing
- Verify drag/click unit selection feels responsive
- Verify visual feedback is clear and immediate
- Verify success animation is satisfying
- Verify recipe discovery notification is noticeable
- Test all 5-10 recipes work as expected

## Dependencies
- Task 003: UnitManager (modify for synthesis operations)
- Task 004: Unit placement system (synthesis location)
- UnitData ScriptableObjects (recipe ingredients/results)

## Notes
- **Conflict with Task 009**: Both tasks modify UnitManager - coordinate changes carefully
- Consider synthesis cost (gold) in future iterations
- Recipe discovery could unlock via achievements/milestones
- Synthesis location should be strategic (consider unit positioning)
- Future: Add synthesis animations (units merging visually)

## Conflicts
- **Task 009 (Unit Upgrade System)**: Both modify UnitManager
  - **Resolution**: Coordinate UnitManager changes, ensure methods don't conflict
  - **Recommendation**: Implement Task 008 first, then Task 009 adds upgrade methods

## Risk Assessment
- **Medium Risk**: UI responsiveness with drag interactions
- **Mitigation**: Optimize recipe validation, use object pooling for UI elements
- **Low Risk**: Recipe balance (can be tuned post-implementation)
