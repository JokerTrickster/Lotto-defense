---
id: "006"
title: "Combat System"
status: "todo"
priority: "high"
estimate: "16h"
tags: ["combat", "ai", "damage", "core-system"]
dependencies: ["003", "004", "005"]
parallel: false
created: "2025-10-28T02:12:15Z"
updated: "2025-10-28T02:12:15Z"
---

# Task 006: Combat System

## Overview
Implement automated combat system where placed units detect and attack monsters within range. Handle damage calculation, monster death rewards, and continuous combat tick system.

## Objectives
- Create CombatManager for combat coordination
- Implement unit target acquisition within attack range
- Build damage calculation system (attack - defense)
- Handle monster death: Award gold, decrease counter
- Create auto-combat coroutine tick system

## Technical Specifications

### Namespace
`LottoDefense.Combat`

### Files to Create
- `Assets/Scripts/Combat/CombatManager.cs` - Combat coordination singleton
- Extend `Assets/Scripts/Units/Unit.cs` - Add combat behavior
- Extend `Assets/Scripts/Monsters/Monster.cs` - Add health/damage handling

### CombatManager Responsibilities
1. **Combat Coordination:**
   - Track all active units and monsters
   - Combat tick rate: 0.1 seconds (10 updates/sec)
   - Coroutine: CombatUpdateRoutine()
   - Manage combat events

2. **Target Acquisition:**
   - For each unit: Find nearest monster in range
   - Priority: First monster along path (lowest waypoint progress)
   - Update targets each tick
   - Handle target death/out-of-range

3. **Damage Processing:**
   - Apply damage based on attack speed intervals
   - Calculate: damage = attacker.attack - defender.defense
   - Minimum damage: 1 (even if defense > attack)
   - Track last attack time per unit

### Unit Combat Extensions
```csharp
// New properties in Unit.cs
- Monster currentTarget
- float lastAttackTime
- bool isAttacking

// New methods
- AcquireTarget() → Monster
- Attack(Monster target)
- IsTargetInRange(Monster) → bool
- GetMonstersInRange() → List<Monster>
- CanAttack() → bool // Check attack speed cooldown
```

### Monster Combat Extensions
```csharp
// New properties in Monster.cs
- int currentHealth
- bool isDead

// New methods
- TakeDamage(int damage)
- Die()
- OnDeath() // Award gold, trigger effects
```

### Target Acquisition Logic
```csharp
// For each unit on grid:
1. Get all monsters within attackRange
2. Filter by path (if unit on top half → target top path)
3. Sort by waypoint progress (closest to end = highest priority)
4. Return first monster or null

// Distance check
float distance = Vector3.Distance(unit.position, monster.position);
bool inRange = distance <= unit.attackRange;
```

### Damage Calculation
```csharp
// Combat formula
int baseDamage = attacker.attack - defender.defense;
int finalDamage = Mathf.Max(1, baseDamage); // Minimum 1 damage

// Attack timing
float timeSinceLastAttack = Time.time - lastAttackTime;
bool canAttack = timeSinceLastAttack >= (1f / attackSpeed);

if (canAttack && HasTarget()) {
    currentTarget.TakeDamage(finalDamage);
    lastAttackTime = Time.time;
    PlayAttackAnimation();
}
```

### Monster Death Handling
```csharp
// Monster.Die() flow
1. Check if already dead (prevent double-processing)
2. Award gold to player: GameManager.AddGold(goldReward)
3. Trigger death animation/effects
4. Decrease monster counter: GameManager.DecreaseMonsterCount()
5. Notify MonsterManager: OnMonsterDied event
6. Return to object pool

// Gold distribution
- Each monster has goldReward in MonsterData
- Gold awarded to GameManager on death
- UI updates automatically via event
```

### Combat Update Loop
```csharp
// CombatManager.CombatUpdateRoutine()
while (gameActive) {
    yield return new WaitForSeconds(0.1f); // 10 ticks/second

    // Get all active units and monsters
    List<Unit> units = UnitManager.GetPlacedUnits();
    List<Monster> monsters = MonsterManager.GetActiveMonsters();

    // Process each unit
    foreach (Unit unit in units) {
        // Acquire or update target
        if (unit.currentTarget == null || !unit.IsTargetInRange(unit.currentTarget)) {
            unit.AcquireTarget();
        }

        // Attack if ready
        if (unit.currentTarget != null && unit.CanAttack()) {
            unit.Attack(unit.currentTarget);
        }
    }
}
```

### Combat Events
```csharp
// Event system for combat feedback
- OnUnitAttack(Unit, Monster)
- OnMonsterDamaged(Monster, int damage)
- OnMonsterDied(Monster)
- OnCombatTick()

// Use for:
- Damage numbers VFX
- Attack animations
- Sound effects
- UI updates
```

## Implementation Steps
1. Create CombatManager singleton
2. Extend Unit class with combat methods
3. Extend Monster class with health/damage handling
4. Implement target acquisition algorithm
5. Build damage calculation system
6. Create combat tick coroutine
7. Integrate monster death handling with rewards
8. Add combat event system for VFX/SFX
9. Test various unit-monster combinations
10. Balance attack speeds and damage values

## Testing Requirements
- Verify target acquisition prioritizes closest to end
- Test damage calculation with various attack/defense values
- Confirm minimum 1 damage rule
- Test attack speed intervals (fast/slow units)
- Verify gold awards on monster death
- Test monster counter decrease
- Validate combat with multiple units and monsters
- Edge case: Monster dies while being targeted
- Edge case: Unit removed during combat
- Performance test: 20 monsters, 10 units

## Dependencies
- **Depends on:** Task 003 (Units), Task 004 (Placement), Task 005 (Monsters)
- **Parallel work:** None - requires all previous systems complete
- **Critical path:** Blocks final integration and testing

## Acceptance Criteria
- [ ] CombatManager coordinates all combat activity
- [ ] Units automatically acquire targets in range
- [ ] Damage calculation: attack - defense (min 1)
- [ ] Attack speed cooldowns respected
- [ ] Monsters die when health reaches 0
- [ ] Gold awarded on monster death
- [ ] Monster counter decreases on death
- [ ] Combat tick runs at 0.1s intervals
- [ ] Target switching when monster dies/leaves range
- [ ] No null reference errors in combat loop
- [ ] Smooth combat with no performance issues

## Notes
- Consider adding critical hit system (future)
- Future: Unit abilities/special attacks
- Future: Monster armor types vs unit damage types
- Future: Debuffer unit effects (slow, weaken)
- Add visual feedback: Damage numbers, hit effects
- Consider attack animations aligned with attack speed
- Balance testing needed after implementation
