# Task 010: Polish, Animations & Balance

## Metadata
```yaml
---
epic: lotto-defense
task_id: "010"
title: "Polish, Animations & Balance"
status: todo
priority: high
estimated_hours: 24
depends_on: ["007", "008", "009"]
parallel: false
created: 2025-10-28T02:12:15Z
updated: 2025-10-28T02:12:15Z
assignee: unity-game-developer
---
```

## Overview
Final polish pass integrating all systems with animations, visual feedback, balance tuning, and performance optimization. Ensures cohesive gameplay experience and mobile readiness.

## Requirements

### Functional Requirements
- **Attack Animations**: Fade/scale tweens for unit attack actions
- **UI Feedback**: Gold gain pop-ups, damage numbers, monster death effects
- **Balance Tuning**: Gold rewards (2-5g per monster), upgrade costs, difficulty curve
- **Mobile Optimization**: Portrait orientation, touch target sizes (min 44x44pt)
- **Performance**: Maintain 60 FPS on target devices
- **Bug Fixes**: Address all issues from playtesting

### Technical Requirements
- **Namespace**: LottoDefense.UI (VFXManager), LottoDefense.Gameplay (BalanceConfig)
- **Dependencies**: All previous tasks (007, 008, 009)
- **Performance Target**: 60 FPS on iPhone 11/Samsung Galaxy S10 equivalent
- **Build Target**: iOS/Android, portrait orientation

## Implementation Plan

### Files to Create
```
Assets/Scripts/UI/VFXManager.cs
Assets/Scripts/UI/DamageNumberPool.cs
Assets/Scripts/UI/FloatingTextPool.cs
Assets/Scripts/Gameplay/BalanceConfig.cs
Assets/Prefabs/VFX/AttackEffect.prefab
Assets/Prefabs/VFX/DamageNumber.prefab
Assets/Prefabs/VFX/GoldPopup.prefab
Assets/Prefabs/VFX/MonsterDeathEffect.prefab
Assets/Animations/UnitAttack.anim
Assets/Animations/UnitHit.anim
Assets/Animations/ButtonPress.anim
```

### Core Components

#### 1. VFXManager.cs
```csharp
namespace LottoDefense.UI
{
    public class VFXManager : MonoBehaviour
    {
        [Header("Effect Prefabs")]
        [SerializeField] private GameObject attackEffectPrefab;
        [SerializeField] private GameObject damageNumberPrefab;
        [SerializeField] private GameObject goldPopupPrefab;
        [SerializeField] private GameObject monsterDeathEffectPrefab;

        [Header("Pools")]
        [SerializeField] private int poolSize = 50;
        private DamageNumberPool damageNumberPool;
        private FloatingTextPool floatingTextPool;

        [Header("Animation Settings")]
        [SerializeField] private float attackAnimationDuration = 0.3f;
        [SerializeField] private AnimationCurve attackScaleCurve;
        [SerializeField] private AnimationCurve attackFadeCurve;

        // Singleton
        public static VFXManager Instance { get; private set; }

        private void Awake()
        {
            if (Instance == null) Instance = this;
            else Destroy(gameObject);

            InitializePools();
        }

        // Visual Effects
        public void PlayAttackAnimation(Unit unit, Monster target);
        public void ShowDamageNumber(Vector3 position, int damage, bool isCritical);
        public void ShowGoldPopup(Vector3 position, int goldAmount);
        public void PlayMonsterDeathEffect(Vector3 position, MonsterData monsterData);
        public void PlayUpgradeEffect(Unit unit);
        public void PlaySynthesisEffect(Vector3 position);

        // Attack Animation
        private IEnumerator AttackAnimationCoroutine(Unit unit, Monster target);

        // Pools
        private void InitializePools();
        private void ReturnToPool(GameObject obj);
    }
}
```

#### 2. DamageNumberPool.cs
```csharp
namespace LottoDefense.UI
{
    public class DamageNumberPool : MonoBehaviour
    {
        [SerializeField] private GameObject damageNumberPrefab;
        [SerializeField] private int poolSize = 30;
        [SerializeField] private float floatSpeed = 2f;
        [SerializeField] private float fadeDuration = 1f;

        private Queue<DamageNumber> pool = new Queue<DamageNumber>();

        public void Initialize();
        public void ShowDamageNumber(Vector3 worldPosition, int damage, bool isCritical);
        private DamageNumber GetFromPool();
        private void ReturnToPool(DamageNumber damageNumber);
    }

    public class DamageNumber : MonoBehaviour
    {
        [SerializeField] private TextMeshProUGUI text;
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private Color normalColor = Color.white;
        [SerializeField] private Color criticalColor = Color.red;

        public void Show(int damage, bool isCritical);
        private IEnumerator AnimateCoroutine();
    }
}
```

#### 3. FloatingTextPool.cs
```csharp
namespace LottoDefense.UI
{
    public class FloatingTextPool : MonoBehaviour
    {
        [SerializeField] private GameObject floatingTextPrefab;
        [SerializeField] private int poolSize = 20;

        private Queue<FloatingText> pool = new Queue<FloatingText>();

        public void Initialize();
        public void ShowFloatingText(Vector3 worldPosition, string text, Color color);
        private FloatingText GetFromPool();
        private void ReturnToPool(FloatingText floatingText);
    }

    public class FloatingText : MonoBehaviour
    {
        [SerializeField] private TextMeshProUGUI text;
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float floatSpeed = 1.5f;
        [SerializeField] private float fadeDuration = 1.2f;

        public void Show(string message, Color color);
        private IEnumerator AnimateCoroutine();
    }
}
```

#### 4. BalanceConfig.cs
```csharp
namespace LottoDefense.Gameplay
{
    [CreateAssetMenu(fileName = "BalanceConfig", menuName = "LottoDefense/Balance Config")]
    public class BalanceConfig : ScriptableObject
    {
        [Header("Gold Rewards")]
        [SerializeField] private int minGoldPerMonster = 2;
        [SerializeField] private int maxGoldPerMonster = 5;
        [SerializeField] private AnimationCurve goldScalingCurve; // Per round

        [Header("Upgrade Costs")]
        [SerializeField] private float upgradeCostBase = 10f;
        [SerializeField] private float upgradeCostExponent = 1.5f;
        [SerializeField] private int maxUpgradeLevel = 10;

        [Header("Difficulty Scaling")]
        [SerializeField] private float hpScalingBase = 1.0f;
        [SerializeField] private float hpScalingMax = 5.0f;
        [SerializeField] private float defenseScalingBase = 1.0f;
        [SerializeField] private float defenseScalingMax = 3.0f;

        [Header("Gacha Probabilities")]
        [SerializeField] private float commonProbability = 0.70f;    // 70%
        [SerializeField] private float uncommonProbability = 0.20f;  // 20%
        [SerializeField] private float rareProbability = 0.08f;      // 8%
        [SerializeField] private float epicProbability = 0.02f;      // 2%

        public int GetGoldReward(int roundNumber);
        public int GetUpgradeCost(int currentLevel);
        public float GetHPMultiplier(int roundNumber);
        public float GetDefenseMultiplier(int roundNumber);
        public void ValidateProbabilities();
    }
}
```

### Animation Implementation

#### Attack Animation (DOTween)
```csharp
public void PlayAttackAnimation(Unit unit, Monster target)
{
    Sequence attackSequence = DOTween.Sequence();

    // Scale punch effect
    attackSequence.Append(unit.transform.DOScale(1.2f, 0.1f));
    attackSequence.Append(unit.transform.DOScale(1.0f, 0.2f));

    // Move towards target and back
    Vector3 originalPosition = unit.transform.position;
    Vector3 targetPosition = Vector3.Lerp(originalPosition, target.transform.position, 0.3f);

    attackSequence.Join(unit.transform.DOMove(targetPosition, 0.15f));
    attackSequence.Append(unit.transform.DOMove(originalPosition, 0.15f));

    // Flash effect
    SpriteRenderer sprite = unit.GetComponent<SpriteRenderer>();
    attackSequence.Join(sprite.DOColor(Color.white, 0.1f).SetLoops(2, LoopType.Yoyo));

    attackSequence.OnComplete(() => {
        // Trigger damage application
        target.TakeDamage(unit.Attack);
    });
}
```

### Balance Tuning Guidelines

#### Gold Economy
```
Early Game (Rounds 1-10):
- 2-3 gold per monster
- Total per round: ~20-40 gold
- Upgrade cost: 10-50 gold

Mid Game (Rounds 11-20):
- 3-4 gold per monster
- Total per round: ~50-80 gold
- Upgrade cost: 50-150 gold
- Synthesis becomes viable

Late Game (Rounds 21-30):
- 4-5 gold per monster
- Total per round: ~80-120 gold
- Upgrade cost: 150-270 gold
- Focus on high-level units
```

#### Difficulty Curve
```
Rounds 1-5: Tutorial phase (easy)
- HP: 1.0x - 1.3x
- Defense: 1.0x - 1.1x

Rounds 6-15: Learning phase (moderate)
- HP: 1.3x - 2.5x
- Defense: 1.1x - 1.5x

Rounds 16-25: Challenge phase (hard)
- HP: 2.5x - 4.0x
- Defense: 1.5x - 2.3x

Rounds 26-30: Victory phase (very hard)
- HP: 4.0x - 5.0x
- Defense: 2.3x - 3.0x
```

### Mobile Optimization

#### Touch Targets
```csharp
[Header("Mobile Settings")]
[SerializeField] private float minTouchTargetSize = 44f; // Apple HIG recommendation
[SerializeField] private float touchTargetPadding = 8f;

private void ValidateTouchTargets()
{
    Button[] buttons = FindObjectsOfType<Button>();
    foreach (Button button in buttons)
    {
        RectTransform rect = button.GetComponent<RectTransform>();
        if (rect.sizeDelta.x < minTouchTargetSize || rect.sizeDelta.y < minTouchTargetSize)
        {
            Debug.LogWarning($"Button {button.name} is too small: {rect.sizeDelta}");
        }
    }
}
```

#### Performance Profiling
```csharp
[Header("Performance Settings")]
[SerializeField] private int targetFrameRate = 60;
[SerializeField] private bool enablePerformanceMonitoring = true;

private void Start()
{
    Application.targetFrameRate = targetFrameRate;
    QualitySettings.vSyncCount = 1;

    if (enablePerformanceMonitoring)
        StartCoroutine(MonitorPerformance());
}

private IEnumerator MonitorPerformance()
{
    while (true)
    {
        yield return new WaitForSeconds(1f);

        float fps = 1f / Time.deltaTime;
        if (fps < 55f)
        {
            Debug.LogWarning($"Performance warning: {fps:F1} FPS");
        }
    }
}
```

### Implementation Steps

1. **Create VFXManager System**
   - Object pooling for damage numbers/floating text
   - Attack animation coroutines
   - Effect prefab instantiation

2. **Implement Attack Animations**
   - Unit attack: Scale punch + move towards target
   - Monster hit: Flash red, shake
   - Critical hit: Larger scale, special color

3. **Create UI Feedback Systems**
   - Damage numbers with float animation
   - Gold pop-ups on monster death
   - Upgrade success particle effects
   - Synthesis transformation animation

4. **Balance Tuning**
   - Create BalanceConfig asset
   - Test gold economy across 30 rounds
   - Adjust difficulty curve for challenge
   - Tune upgrade cost progression

5. **Mobile Build Configuration**
   - Set portrait orientation
   - Validate touch target sizes
   - Test on target devices (iOS/Android)
   - Optimize draw calls and memory usage

6. **Performance Optimization**
   - Profile with Unity Profiler
   - Optimize particle systems
   - Reduce garbage collection
   - Object pooling for frequently spawned objects

7. **Playtesting & Bug Fixes**
   - Full playthrough (rounds 1-30)
   - Test all systems integration
   - Fix edge cases and bugs
   - Polish based on feedback

## Acceptance Criteria
- [ ] Attack animations play smoothly (fade/scale tweens)
- [ ] Damage numbers display on all attacks
- [ ] Gold pop-ups show on monster death with amount (2-5g)
- [ ] Monster death effects play (particles/animation)
- [ ] All UI buttons have min 44x44pt touch targets
- [ ] Game maintains 60 FPS on target devices
- [ ] Portrait orientation enforced on mobile
- [ ] Balance tuning: Gold economy feels rewarding, difficulty progression is fair
- [ ] All playtesting bugs fixed
- [ ] Mobile build successfully deploys to iOS/Android

## Testing Strategy

### Unit Tests
```csharp
[Test]
public void BalanceConfig_GetGoldReward_Round1_Returns2To5();
[Test]
public void BalanceConfig_GetUpgradeCost_ValidatesFormula();
[Test]
public void BalanceConfig_GetHPMultiplier_Round30_ReturnsMax();
[Test]
public void VFXManager_DamageNumberPool_HandlesHighLoad();
[Test]
public void VFXManager_AttackAnimation_CompletesInExpectedTime();
```

### Integration Tests
- Test attack animation → damage number → gold popup flow
- Test upgrade success → particle effect
- Test synthesis → transformation animation
- Test round completion → phase transition animations

### Performance Tests
- Profile 30-round playthrough for FPS drops
- Stress test with max units (10) and many monsters
- Memory leak detection (extended play sessions)
- Load test damage number pool (100+ simultaneous)

### Manual Testing
- **Visual Polish**: All animations feel smooth and satisfying
- **Audio Feedback**: All actions have appropriate sound effects
- **Mobile UX**: Touch targets are comfortable, text is readable
- **Balance Feel**: Progression feels rewarding, difficulty is fair
- **Bug Sweep**: Test all edge cases and system interactions

## Dependencies
- Task 007: Round Management (phase transitions, victory/defeat)
- Task 008: Unit Synthesis (synthesis animations)
- Task 009: Unit Upgrade (upgrade feedback)
- All previous tasks (complete game integration)

## Notes
- **Final Integration Task**: This task ties all systems together
- **Balance Iteration**: Expect multiple tuning passes based on playtesting
- **Performance Budget**:
  - Draw calls: < 100
  - Memory: < 500MB
  - Load time: < 3 seconds
- **Polish Scope**: Focus on core gameplay loop polish, defer advanced features
- **Future Enhancements**: Consider adding sound effects, advanced particle systems

## Risk Assessment
- **Medium Risk**: Performance on lower-end devices
- **Mitigation**: Extensive profiling, quality settings for different device tiers
- **Medium Risk**: Balance tuning requires iteration
- **Mitigation**: Make all balance values easily adjustable in BalanceConfig asset
- **Low Risk**: Animation timing/feel is subjective
- **Mitigation**: Gather playtester feedback, iterate on timing curves

## Post-Launch Considerations
- **Analytics**: Track player progression, round completion rates
- **A/B Testing**: Test different balance configurations
- **Difficulty Options**: Easy/Normal/Hard modes
- **Accessibility**: Colorblind mode, adjustable text sizes
- **Monetization**: IAP for cosmetics, premium units (if applicable)
